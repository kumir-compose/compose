|
| Kumir JSON API
| @author Tapeline
| @version 1
|

|| включить k-collections/kcollections.kum

алг сим __json_ток_сим(арг лит исхКод, арг цел индекс) нач
если индекс > длин(исхКод) или индекс < 1 то
знач := юнисимвол(0)
иначе
знач := исхКод[индекс]
все
кон

алг лог __json_ток_сим_числовой(арг сим с) нач
знач := (юникод('0') <= юникод(с) <= юникод('9'))
кон

алг лог __json_ток_сим_буквенный(арг сим с) нач
знач := (юникод('a') <= юникод(с) <= юникод('z')) или (юникод('A') <= юникод(с) <= юникод('Z')) или с = '_'
кон

алг лог __json_ток_сим_16ый(арг сим с) нач
знач := __json_ток_сим_числовой(с) или (юникод('a') <= юникод(с) <= юникод('f')) или (юникод('A') <= юникод(с) <= юникод('F')) или с = '_'
кон

алг лог __json_ток_сим_пропускать(арг сим с) нач
| Игнорировать \n \t \r и пробел
цел к
к := юникод(с)
знач := к = 9 или к = 10 или к = 13 или к = 32
кон

алг лог __json_валидная16Строка(арг лит строка) нач
знач := да
цел индекс
нц для индекс от 1 до длин(строка)
если не __json_ток_сим_16ый(строка[индекс]) то
знач := нет
все
кц
кон


алг лит __json_токенизировать(арг лит исхКод, аргрез лит ошибка) нач
цел текущий = 1
цел старт = 1
сим текущийСим
лит токены
лог плавающий = нет
лит управлПосл = ""
лит строка = ""
лог строкаПродолж = нет
ошибка := ""
токены := новыйСписок
нц пока текущий <= длин(исхКод)
если ошибка <> "" то выход все
старт := текущий
текущийСим := исхКод[текущий]
текущий := текущий + 1
выбор 
при __json_ток_сим_пропускать(текущийСим): | пропустить
при текущийСим = '[': добавитьККонцуСписка(токены, "[")
при текущийСим = ']': добавитьККонцуСписка(токены, "]")
при текущийСим = '{': добавитьККонцуСписка(токены, "{")
при текущийСим = '}': добавитьККонцуСписка(токены, "}")
при текущийСим = ',': добавитьККонцуСписка(токены, ",")
при текущийСим = ':': добавитьККонцуСписка(токены, ":")
при __json_ток_сим_числовой(текущийСим) или текущийСим = "-":
нц пока __json_ток_сим_числовой(__json_ток_сим(исхКод, текущий))
текущий := текущий + 1
кц
если исхКод[старт:текущий-1] = "-" то 
ошибка := "TOKEN_INVALID_NUMBER" 
выход 
все
плавающий := нет
если __json_ток_сим(исхКод, текущий) = '.' и __json_ток_сим_числовой(__json_ток_сим(исхКод, текущий+1)) то
плавающий := да
текущий := текущий + 1
нц пока __json_ток_сим_числовой(__json_ток_сим(исхКод, текущий))
текущий := текущий + 1
кц
все
если плавающий то
добавитьККонцуСписка(токены, "F" + исхКод[старт:текущий-1])
иначе
добавитьККонцуСписка(токены, "I" + исхКод[старт:текущий-1])
все
при текущийСим = '"':
строка := ""
нц пока __json_ток_сим(исхКод, текущий) <> '"'
строкаПродолж := нет
если управлПосл = "\" то
выбор 
при __json_ток_сим(исхКод, текущий) = '"':
строка := строка + '"'
управлПосл := ""
строкаПродолж := да
текущий := текущий + 1
при __json_ток_сим(исхКод, текущий) = '\':
строка := строка + '\'
управлПосл := ""
строкаПродолж := да
текущий := текущий + 1
при __json_ток_сим(исхКод, текущий) = 'b':
строка := строка + юнисимвол(8)
управлПосл := ""
строкаПродолж := да
текущий := текущий + 1
при __json_ток_сим(исхКод, текущий) = 'f':
строка := строка + юнисимвол(12)
управлПосл := ""
строкаПродолж := да
текущий := текущий + 1
при __json_ток_сим(исхКод, текущий) = 'r':
строка := строка + юнисимвол(13)
управлПосл := ""
строкаПродолж := да
текущий := текущий + 1
при __json_ток_сим(исхКод, текущий) = 'n':
строка := строка + юнисимвол(10)
управлПосл := ""
строкаПродолж := да
текущий := текущий + 1
при __json_ток_сим(исхКод, текущий) = 't':
строка := строка + юнисимвол(9)
управлПосл := ""
строкаПродолж := да
текущий := текущий + 1
при __json_ток_сим(исхКод, текущий) = 'u':
управлПосл := ""
управлПосл := управлПосл + __json_ток_сим(исхКод, текущий+1)
управлПосл := управлПосл + __json_ток_сим(исхКод, текущий+2)
управлПосл := управлПосл + __json_ток_сим(исхКод, текущий+3)
управлПосл := управлПосл + __json_ток_сим(исхКод, текущий+4)
если длин(управлПосл) <> 4 или не __json_валидная16Строка(управлПосл) то
ошибка := "TOKEN_INVALID_U_SEQUENCE"
выход
все
строка := строка + юнисимвол(hexToDec(управлПосл))
текущий := текущий + 5
управлПосл := ""
строкаПродолж := да
все
если ошибка <> "" то выход все


иначе
если __json_ток_сим(исхКод, текущий) = "\" и не строкаПродолж то
управлПосл := "\"
иначе
если не строкаПродолж то
строка := строка + __json_ток_сим(исхКод, текущий)
все

все

текущий := текущий + 1
все
если ошибка <> "" то выход все

кц
если текущий > длин(исхКод) то
ошибка := "TOKEN_UNEXPECTED_EOF"
выход
все
текущий := текущий + 1
добавитьККонцуСписка(токены, "S" + строка)
иначе
нц пока __json_ток_сим_буквенный(__json_ток_сим(исхКод, текущий))
текущий := текущий + 1
кц
если исхКод[старт:текущий-1] = "true" или исхКод[старт:текущий-1] = "false" или исхКод[старт:текущий-1] = "null" то
добавитьККонцуСписка(токены, исхКод[старт:текущий-1])
иначе
ошибка := "TOKEN_UNEXPECTED_ID"
все
все
кц
знач := токены
кон

алг лит __json_соотв(арг лит токены, аргрез цел текущий, арг лит типТокена) нач
если текущий > длинаКоллекции(токены) то
знач := ""
выход
все
лит токен
токен := получитьИзСписка(токены, текущий)
если __json_ток_сим_буквенный(типТокена[1]) и токен[1] = типТокена то
текущий := текущий + 1
знач := токен
выход
все
если токен = типТокена то
текущий := текущий + 1
знач := токен
выход
все
знач := ""
кон

алг лит __json_соотвТекст(арг лит токены, аргрез цел текущий, арг лит текст) нач
если текущий > длинаКоллекции(токены) то
знач := ""
выход
все
лит токен
токен := получитьИзСписка(токены, текущий)
если токен = текст то
текущий := текущий + 1
знач := токен
выход
все
знач := ""
кон

алг лит __json_требовать(арг лит токены, аргрез цел текущий, арг лит типТокена, аргрез лит ошибка) нач
лит токен = ""
токен := __json_соотв(токены, текущий, типТокена)
если токен = "" то
ошибка := "PARSE_EXPECTED_"+типТокена
выход
все
знач := токен
кон

алг лит парситьЖсон(арг лит токены, аргрез цел текущий, аргрез лит ошибка) нач 
лит выражение, токен, ключ, жсонОбъект
знач := ""
если __json_соотв(токены, текущий, "{") <> "" то
если __json_соотв(токены, текущий, "}") <> "" то
знач := новыйОбъект
выход
все
жсонОбъект := новыйОбъект
нц
ключ := __json_требовать(токены, текущий, "S", ошибка)
если ошибка <> "" то выход все
токен := __json_требовать(токены, текущий, ":", ошибка)
если ошибка <> "" то выход все
выражение := парситьЖсон(токены, текущий, ошибка)
если ошибка <> "" то выход все
задатьПоКлючу(жсонОбъект, ключ[2:длин(ключ)], сериализовать(выражение))
если __json_соотв(токены, текущий, ",") = "" то выход все
кц
знач := жсонОбъект
выход
все

если __json_соотв(токены, текущий, "[") <> "" то
если __json_соотв(токены, текущий, "]") <> "" то
знач := новыйОбъект
выход
все
жсонОбъект := новыйСписок
нц
выражение := парситьЖсон(токены, текущий, ошибка)
если ошибка <> "" то выход все
добавитьККонцуСписка(жсонОбъект, сериализовать(выражение))
если __json_соотв(токены, текущий, ",") = "" то выход все
кц
знач := жсонОбъект
выход
все

если __json_соотв(токены, текущий, "I") <> "" то
знач := получитьИзСписка(токены, текущий - 1)
выход
все

если __json_соотв(токены, текущий, "F") <> "" то
знач := получитьИзСписка(токены, текущий - 1)
выход
все

если __json_соотв(токены, текущий, "null") <> "" то
знач := "null"
выход
все
если __json_соотв(токены, текущий, "true") <> "" то
знач := "true"
выход
все
если __json_соотв(токены, текущий, "false") <> "" то
знач := "false"
выход
все

если __json_соотв(токены, текущий, "S") <> "" то
знач := получитьИзСписка(токены, текущий - 1)
выход
все

ошибка := "PARSER_UNEXPECTED_" + получитьИзСписка(токены, текущий)
знач := ""
кон

алг лит __json_обрезатьТочки(арг лит текст) нач
лит нт
нт := текст
если длин(текст) = 0 то 
знач := текст
выход
все
если нт[1] = "." то
нт := нт[2:длин(нт)]
все
если длин(нт) = 0 то 
знач := нт
выход
все
если нт[длин(нт)] = "." то
нт := нт[1:длин(нт)-1]
все
знач := нт
кон


алг лит разложитьЖсон(арг лит жсон) нач
лит объ, контекст = ""
объ := новыйОбъект
__разложитьЖсон(жсон, объ, контекст)
знач := объ
кон

алг __разложитьЖсон(арг лит жсон, аргрез лит плоскийОбъект, арг лит контекст) нач
цел индекс = 1
лит ключи, значения, ключ, значение
выбор 
при являетсяОбъектом(жсон):
индекс := 1
разобратьОбъект(жсон, ключи, значения)
нц для индекс от 1 до длинаКоллекции(ключи) 
ключ := получитьИзСписка(ключи, индекс)
значение := получитьИзСписка(значения, индекс)
__разложитьЖсон(десериализовать(значение), плоскийОбъект, контекст + "." + ключ) 
кц
при являетсяСписком(жсон):
индекс := 1
нц для индекс от 1 до длинаКоллекции(жсон) 
значение := получитьИзСписка(жсон, индекс)
__разложитьЖсон(десериализовать(значение), плоскийОбъект, контекст + "[" + цел_в_лит(индекс) + "]" + ".")
кц
задатьПоКлючу(плоскийОбъект, __json_обрезатьТочки(контекст + ".__len__"), цел_в_лит(длинаКоллекции(жсон)))
иначе

задатьПоКлючу(плоскийОбъект, __json_обрезатьТочки(контекст), жсон)
все
кон

алг лит считатьЖсон(арг лит жсон, аргрез лит ош) нач
лит токены, ошибка = "", объект
токены := __json_токенизировать(жсон, ошибка)
если ошибка <> "" то
знач := ""
ош := ошибка
выход
все
цел индекс = 1
ошибка := ""
знач := парситьЖсон(токены, индекс, ошибка)
если ошибка <> "" то
знач := ""
ош := ошибка
выход
все
кон